% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slab_shrink.R
\name{slab_shrink}
\alias{slab_shrink}
\title{Slab and Shrinkage Generalised LASSO Estimator}
\usage{
slab_shrink(
  x,
  y,
  u = 1,
  lambda = NULL,
  nlambda = 100,
  models = c("SR", "ST", "DSH", "SH"),
  exclude = NULL,
  ...
)
}
\arguments{
\item{x}{Input matrix of dimension n x p, where n is the number of observations
and p is the number of variables. The matrix should not include an intercept
term as this will be handled internally if needed.}

\item{y}{Response variable vector with n observations.}

\item{u}{A numeric or numeric vector that represents the tuning parameter(s)
for regularization strength in the model. Defaults to 1. If a vector is provided,
the first element should be the tuning value for the intercept, followed by
tuning values for other coefficients.}

\item{lambda}{A numeric value, vector or NULL.
If NULL, the function will automatically determine the optimal lambda value
using cross-validation with cv.glmnet(). The optimal lambda, selected based
on the given criteria (typically the one minimizing prediction error), will be
used for subsequent regression models, and this value will be returned as the
best lambda.
If a lambda value is provided by the user, this specified value will be used
directly in the regression models without further modification, and the same
value will be returned.}

\item{nlambda}{The number of lambda values to be used if lambda is not specified.
This is typically used in conjunction with cross-validation to determine the
optimal lambda. Note that specifying both `nlambda` and `lambda` simultaneously
is not allowed and will result in an error.}

\item{models}{A character vector specifying which regression models to estimate.
Available choices are:
\itemize{
  \item{'SR': }{Slab Regression}
  \item{'ST': }{Stein Regression}
  \item{'DSH': }{Diagonal Shrinkage Regression}
  \item{'SH': }{Shrinkage Regression}
}
The specified models will be applied sequentially to the input data. If no models
are provided by the user, all four models will be processed by default, and the results
for each will be included in the output.}

\item{exclude}{An optional vector of column indices to be excluded from the
input matrix x before the model fitting. This allows for the omission of
variables that are not to be considered in the analysis.}

\item{...}{}
}
\value{
A list of results with class 'custom_lm' containing the following components:
\describe{
  \item{coefficients}{A list of coefficient vectors for each specified model (SR, ST, DSH, SH).}
  \item{fitted.values}{A list of fitted values for each specified model.}
  \item{residuals}{A list of residuals for each specified model.}
  \item{est}{The estimated parameter vector \code{theta}.}
  \item{cvm}{The cross-validation mean squared error.}
  \item{cvsd}{The cross-validation standard deviation.}
  \item{lambda_range}{The range of lambda values used in the cross-validation.}
  \item{u}{The regularization parameter vector \code{u}.}
  \item{lambda}{The best lambda value selected.}
  \item{sigma}{The estimated error variance.}
  \item{model}{The list of models specified.}
}
}
\description{
This function implements the Slab and Shrinkage Generalised LASSO Estimation
method for regression models.
}
\examples{
Set a random seed for reproducibility
set.seed(123)

# Define the number of observations and variables
n <- 100 # Number of observations
p <- 5   # Number of variables

# Generate random data for predictors
test_x <- matrix(rnorm(n * p), n, p)

# Generate coefficients including an intercept
beta <- matrix(rnorm(p + 1), p + 1, 1)

# Calculate response variable with added noise
test_y <- cbind(1, test_x) \%*\% beta + rnorm(n, sd = 0.5)

# Fit a model using a fictional slab_shrink function
result <- slab_shrink(test_x, test_y) # Estimation works with just x and y
print(result)

# Fit models "ST" and "DSH" using a fictional slab_shrink function
result_ST_DSH <- slab_shrink(test_x, test_y, models = c("ST", "DSH"))
print(result_ST_DSH)

# Fit a model using a fictional slab_shrink function with a specific u value
result_u_2 <- slab_shrink(test_x, test_y, u = 2)
print(result_u_2)
# Fit a model with a vector of u values including tuning for intercept
result_u_vector <- slab_shrink(test_x, test_y, u = c(0, 1:5))
print(result_u_vector)

# Fit a model with a specific lambda value
result_lambda_10 <- slab_shrink(test_x, test_y, lambda = 10)
print(result_lambda_10)
# Fit a model with a vector of randomly generated lambda values
result_lambda_vector <- slab_shrink(test_x, test_y, lambda = runif(10, min = 0, max = 10))
print(result_lambda_vector)

# Fit a model excluding the first and third predictors from x
# This might be useful to test the impact of specific variables on the model
result_exclude_1_3 <- slab_shrink(test_x, test_y, exclude = c(1,3))
print(result_exclude_1_3)


}
